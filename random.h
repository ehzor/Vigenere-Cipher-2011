#ifndef __RANDOM_H
#define __RANDOM_H

#include <stdint.h>
#include <inttypes.h>
#include <stdio.h>
#include <time.h>
#include "debug.h"
#include "mt.h"

/**
 * KEEP ON TOP
 *
 * 64-bit version of MWC.
 * Credit: http://www.velocityreviews.com/forums/t673657-64-bit-kiss-rngs.html
 *
 * Modified so its not a static (rands are supposed to be random :D)
 *
 * Returns 64-bit integer (unsigned) of a random number.
 * Seeds are generated by reading data from /dev/urandom
 **/

#define MWC (t=(x<<58)+c, c=(x>>6), x+=t, c+=(x<t), x)
#define XSH ( y^=(y<<13), y^=(y>>17), y^=(y<<43) )
#define CNG ( z=k*z+g )
#define KISS(c,k,g,x,y,z,t) (MWC+XSH+CNG)

uint64_t getrand(uint64_t c, uint64_t k, uint64_t g, uint64_t x, uint64_t y, uint64_t z){
        uint64_t t; // Dummy variable that serves no purpose (t = KISS(...) (w/o t var) also possible)

        return KISS(c, k, g, x, y, z, t);
}

/**
 * /KEEP ON TOP
 **/

/**
 * rndseedkey()
 * digits:	How long the key is in bits.	[in]
 *
 * Generates a random number using the M-T random number generator.
 * Since seeds have to be given to GMP, and to ensure random numbers are random, a random seed is given.
 *
 * Returns the random number to be given to the generator.
 **/
uint64_t rndseedkey(uint64_t digits){
	/**
	 * Some people hate people that use time for a RNG.
	 * I do too, but since it's only done to feed the real RNG, no worries.
	 **/
	time_t tt;
	struct tm *ti;

	time(&tt);
	ti = localtime(&tt);

	// Using 64-bit numbers to make things better for the encryption side
	uint64_t s, m, h, y, x, z;
	s = ti->tm_sec;
	m = ti->tm_min;
	h = ti->tm_hour;
	y = ti->tm_yday;

	// Do a little bit of trickery (not really big)
	x = (s + m + h + y) / digits;
	z = ((s + m + h + y) * digits);

	// Initialize the RNG using yet another RNG (weird, huh?)
	init_genrand64(getrand(s, m, h, y, x, z));

	// Finally, get the random number
	return genrand64_int64();
}

/**
 * URandom()
 * bytes:	Amount of bytes to read from device	[in]
 * buff:	Buffer to hold retrieved bytes		[out]
 *
 * Reads x bytes from /dev/urandom and returns it in buff.
 * !! buff is NOT allocated in function, MUST be allocated before use.
 *
 * Returns number of bytes read.
 **/
uint64_t URandom(int bytes, char *buff){
	FILE *fp;
	int len = 0;
	char c;

	fp = fopen("/dev/urandom", "rb");

	if(!fp){
		printf("Unable to open /dev/urandom!\n");
		return 0;
	}

	/* Best attempt at getting all *bytes* of data...
	 * It was either this or constant strlen(buff) calls...this is less intensive
	 **/
	while(len < bytes){
		c = fgetc(fp);

		// Anything from " " - "~" are accceptable (see ASCII table if confused)
		if((c >= ' ') && (c <= '~')){
			buff[len] = c;

			len++;
		}
	}

	fclose(fp);

	return len;
}

#endif
